

## Running DART

Once DART is installed and the DART IPs are available, the next is step
is to test DART with some simple example design. 

### Example of a DART Design with the `memcpy` IP

This is an image of the block design automatically generated by DART with one reconfigurable reagion and one `memcpy` IP.

![DART block design with 1 RR](docs/images/FRED-static-1rr.png)


The following report includes one memcpy IP and it considers the board PYNQ-Z1 (xc7z020clg400-1). 

|          Site Type         | Used | Fixed | Available | Util% |
|----------------------------|-----:|------:|----------:|------:|
| Slice LUTs*                | 2418 |     0 |     53200 |  4.55 |
|   LUT as Logic             | 2224 |     0 |     53200 |  4.18 |
|   LUT as Memory            |  194 |     0 |     17400 |  1.11 |
|     LUT as Distributed RAM |   10 |     0 |           |       |
|     LUT as Shift Register  |  184 |     0 |           |       |
| Slice Registers            | 3268 |     0 |    106400 |  3.07 |
|   Register as Flip Flop    | 3268 |     0 |    106400 |  3.07 |
|   Register as Latch        |    0 |     0 |    106400 |  0.00 |
| F7 Muxes                   |    0 |     0 |     26600 |  0.00 |
| F8 Muxes                   |    0 |     0 |     13300 |  0.00 |


The following report includes three memcpy IPs and it considers the board PYNQ-Z1 
(xc7z020clg400-1). 

![DART block design with 3 RRs](docs/images/FRED-static-3rr.png)


|          Site Type         | Used | Fixed | Available | Util% |
|----------------------------|-----:|------:|----------:|------:|
| Slice LUTs*                | 6009 |     0 |     53200 | 11.30 |
|   LUT as Logic             | 5548 |     0 |     53200 | 10.43 |
|   LUT as Memory            |  461 |     0 |     17400 |  2.65 |
|     LUT as Distributed RAM |   10 |     0 |           |       |
|     LUT as Shift Register  |  451 |     0 |           |       |
| Slice Registers            | 7986 |     0 |    106400 |  7.51 |
|   Register as Flip Flop    | 7986 |     0 |    106400 |  7.51 |
|   Register as Latch        |    0 |     0 |    106400 |  0.00 |
| F7 Muxes                   |    0 |     0 |     26600 |  0.00 |
| F8 Muxes                   |    0 |     0 |     13300 |  0.00 |


#### DART/FRED Interface

DART automates only the hardware design of the hardware/software system based on Zynq.
As seen before, it generates two sets of outputs: the bitstreams and the FRED configuration files.

This section shows the DART outputs assuming a design with a single `memcpy` IP.
Under the generated DART design directory there is a `fred` directory with the following structure:

```bash
$ cd fred
$ tree
.
├── arch.csv
├── hw_tasks.csv
├── dart_fred
    └── bits
        ├── p0
        │   └── memcpy_s0.bin
        └── static.bin
```

The FRED configuration files are `arch.csv` and `hw_tasks.csv`, and 
the next blocks of code show an example of both files:

```bash
$ cat arch.csv 
# FRED Architectural description file. 
# Warning: This file must match synthesized hardware! 
 
# Each line defines a partition, syntax: 
# <partition name>, <num slots> 
 
# example: 
# "ex_partition, 3" 
# defines a partion named "ex_partition" containing 3 slots
p0, 1
```

The example above shows that the generated design has a single partition called `p0`
and it has a single slot (i.e. IP) assigned to it. In case of multiple partitions, 
each partition is reported in a new line of the CSV file.


```bash
$ cat hw_tasks.csv
# FRED hw-tasks description file. 
 # Warning: This file must match synthesized hardware! 
 
# Each line defines a HW-Tasks: 
 # <name>, <hw_id>, <partition>, <bistream_path>, <buff_0_size>, ... <buff_7_size> 
 # Note: the association between a hw-task and its partition 
 # it's defined during the synthesis flow! Here is specified only 
 # to guess the number of bistreams and their length. 
 
 # example: 
 # "ex_hw_task, 64, ex_partition, bits, 1024, 1024, 1024" 
 # defines a hw-task named "ex_hw_task", with id 64, allocated on a 
 # partition named "ex_partition", whose bitstreams are located in 
 # the "/bits" folder, and uses three input/output buffers of size 1024 bytes. 
 
 memcpy, 100, p0, dart_fred/bits, 1048576, 32768
```

The block above shows the corresponding `hw_tasks.csv` file for the same example design. It shows the name of the IP, its Hw ID, the partition it is assigned, 
the bitstream location, and the sizes of the input and output buffers.
If the design has multiple IPs, each one appears in a different line.



### Example for pr_tool_without_part

The following example is for *pr_tool_without_part*, assuming five IPs and two partitions.
Partition 0 with IPs mul, nor, and xor, and partition 1 with the IPs sum and sub.

```
1,sum_vec,sum_vec_top
0,mul_vec,mul_vec_top
1,sub_vec,sub_vec_top
0,nor_vec,nor_vec_top
0,xor_vec,xor_vec_top
```

**RUN AND SHOW THE EXPECTED OUTPUT**

### Example for pr_tool_with_part

The next example is for *pr_tool_with_part*, assuming the same five IPs.
Note that the partitions are not defined bu the user. It will be defined by DART.
In this case, each IP has a runtime of 100 ns and a deadline of 1000 ns. 
**IS THE UNIT CORRECT ?**

```
100,1000,sum_vec,sum_vec_top
100,1000,mul_vec,mul_vec_top
100,1000,sub_vec,sub_vec_top
100,1000,nor_vec,nor_vec_top
100,1000,xor_vec,xor_vec_top
```

**RUN AND SHOW THE EXPECTED OUTPUT**

### Example for FLORA

**PUT HERE EXAMPLES FOR RUNNING FLORA**

**RUN AND SHOW THE EXPECTED OUTPUT**


