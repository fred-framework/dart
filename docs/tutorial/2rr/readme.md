
### Two Reconfigurable Regions

This tutorial describes an example using the following partition:
- part 0: sum_vec, sub_vec, mul_vec;
- part 1: xor_vec, nor_vec.

Thus, in this tutorial we are trying to meet the hw task deadlines by increasing the number of reconfigurable reagions.

#### Generating the bitstreams

- Make sure that DART was compiled to your board and with **PARTITIONING_MODE** `OFF`;
- Make sure that these environment variables are set **XILINX_VIVADO**, **XILINX_HLS**, **DART_HOME**;
- If the required IPs were not compiled previoulsly, then edit the script in this directory to `compile_ips=1`;
- If the required IPs were compiled previoulsly, then make sure that **DART_IP_PATH** is set;
- Run `run.sh` and wait until the end of the synthesis;
- The FRED generated configuration files, the devicetree, and bitstreams are in the `fred.tar.gz` file.

In this example, for ZCU102 board, expect an error like this

```
```

This means that floorplan for the reconfigurable reagion `pblock_slot_1` is failing. This is cause by current limitations documented in [Issue #1](). Fortunatly, circuventing this limitation is easy. This error raises in the implementation phase, when the bitstream are generated. DART runs the script `impl.tcl` with vivado, using the floorplanning constraint file generated by DART (located in `Sources/constraints/pblocks.xdc`) to place the hw tasks onto the FPGA. We have to patch this XDC file manually. 

- Open vivado project located in `static_hw/dart_project.xpr` using the GUI;
- Add the contraint file to the project;
- Click in `Open the Synthesized Design`. You will see the window like this one, with the two reconfigurable regions assigned by DART;
- Identify the failing reconfigurable region `pblock_slot_1`, in this case is the one in the left hand side;
- Click the mouse in the right hand side of the retangle and drag it two rows to the right hand side. This will expand the retangle area, enough to avoid the error seen beafore;
- Copy the command in the Tcl Console window. It must be something similar to 
```
resize_pblock pblock_slot_1 -add {SLICE_X1Y180:SLICE_X4Y419 DSP48E2_X0Y72:DSP48E2_X0Y167 RAMB18_X0Y72:RAMB18_X0Y167 RAMB36_X0Y36:RAMB36_X0Y83} -remove {SLICE_X2Y180:SLICE_X4Y419 DSP48E2_X0Y72:DSP48E2_X0Y167 RAMB18_X0Y72:RAMB18_X0Y167 RAMB36_X0Y36:RAMB36_X0Y83} -locs keep_all
```
- Paste this command in the `Sources/constraints/pblocks.xdc` file, replacing the previous `pblock_slot_1` configuration. The resulting block should be similat to this one:

```
set_property HD.RECONFIGURABLE true [get_cells dart_i/acc_1/inst]
create_pblock pblock_slot_1
add_cells_to_pblock [get_pblocks pblock_slot_1] [get_cells -quiet [list dart_i/acc_1/inst]]
#resize_pblock [get_pblocks pblock_slot_1] -add {SLICE_X0Y180:SLICE_X2Y419}
#resize_pblock [get_pblocks pblock_slot_1] -add {RAMB18_X0Y72:RAMB18_X0Y167}
#resize_pblock [get_pblocks pblock_slot_1] -add {RAMB36_X0Y36:RAMB36_X0Y83}
resize_pblock pblock_slot_1 -add {SLICE_X1Y180:SLICE_X4Y419 DSP48E2_X0Y72:DSP48E2_X0Y167 RAMB18_X0Y72:RAMB18_X0Y167 RAMB36_X0Y36:RAMB36_X0Y83} -remove {SLICE_X2Y180:SLICE_X4Y419 DSP48E2_X0Y72:DSP48E2_X0Y167 RAMB18_X0Y72:RAMB18_X0Y167 RAMB36_X0Y36:RAMB36_X0Y83} -locs keep_all
set_property RESET_AFTER_RECONFIG true [get_pblocks pblock_slot_1]
set_property SNAPPING_MODE ON [get_pblocks pblock_slot_1]
```
- Run the implementation again executing `vivado -mode batch -source impl.tcl`

#### Running in the board

Similar to the previous tutorial, run the following commands in the board:

```
$ update_hw <user> <ip> <path>
$ load_hw
$ fred-server &
```

#### Analysing the results

In another terminal, run:

```
$ app
```

We execute the same application run before in [one reconfigurable region](../2rr/readme.md). However, in this case all timing constraints are met since we dont see neither mismatch nor timeout messages. This means that this configuration meets the timing constraints. 

Next we test a similar configuration, but in this case DART will decide the [most cost effective partition](../part/readme.md) that meets the hw tasks timing constraints. It means the the user does not have to try different configurations to check whether the constraints are met or not.
