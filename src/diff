6d5
< using namespace std;
7a7
> using namespace std;
13a14,15
> 
> 
20c22
< static unsigned long BIG_M = 10000000;
---
> static unsigned long BIG_M = 100000;
23c25
< unsigned long wasted_clb_zynq , wasted_bram_zynq , wasted_dsp_zynq ;
---
> static unsigned long wasted_clb_pynq, wasted_bram_pynq, wasted_dsp_pynq;
27,30c29,31
< 
< static unsigned long clb_max = 10000;
< static unsigned long bram_max = 10000;
< static unsigned long dsp_max = 10000;
---
> static unsigned long clb_max  = 30000;
> static unsigned long bram_max = 1000;
> static unsigned long dsp_max  = 1000;
35,41c36,38
< static vector<unsigned long> clb_req_zynq (MAX_SLOTS);
< static vector<unsigned long> bram_req_zynq(MAX_SLOTS);
< static vector<unsigned long> dsp_req_zynq (MAX_SLOTS);
< 
< Taskset *task_set;
< Platform *platform;
< vector <double> slacks = vector<double>(MAX_SLOTS);
---
> static vector<unsigned long> clb_req_pynq(MAX_SLOTS);
> static vector<unsigned long> bram_req_pynq(MAX_SLOTS);
> static vector<unsigned long> dsp_req_pynq(MAX_SLOTS);
43,44c40,41
< static vector <vector <unsigned long>> conn_matrix_zynq = vector <vector<unsigned long>> (MAX_SLOTS, vector<unsigned long> (MAX_SLOTS, 0));;
< static unsigned long num_conn_slots_zynq;
---
> static vector <vector <unsigned long>> conn_matrix_pynq = vector <vector<unsigned long>> (MAX_SLOTS, vector<unsigned long> (MAX_SLOTS, 0));;
> static unsigned long num_conn_slots_pynq;
46c43
< static Vecpos fs_zynq(MAX_SLOTS);
---
> static Vecpos fs_pynq(MAX_SLOTS);
48,49c45
< //int solve_milp(param_from_solver *to_sim)
< int solve_milp(Taskset &t, Platform &platform, vector<double> &slacks, bool preemptive_FRI, param_from_solver *to_sim)
---
> int solve_milp_pynq(param_from_solver *to_sim)
51c47,48
<     unsigned long status, i ,k, j, l, m;
---
>     int status;
>     unsigned long i ,k, j, l, m;
53,54c50
<     unsigned long num_active_partitions = 0;
<     
---
> 
67,180d62
<        //Variables for partioning
<         // ------------------------------------------------------------
<         // Variable defintion: b
<         // Meaning: b[x][k] = number of FPGA resources of type 'x',
<         //          in the 'k'-th partition
<         // ------------------------------------------------------------
< 
<         GRBVar2DArray b(platform.N_FPGA_RESOURCES);
<         for(uint x=0; x < platform.N_FPGA_RESOURCES; x++)
<         {
<             GRBVarArray per_partition(t.maxPartitions);
<             b[x] = per_partition;
< 
<             for(uint k=0; k < t.maxPartitions; k++)
<                 b[x][k] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_CONTINUOUS);
<         }
< 
< 
<         // ------------------------------------------------------------
<         // ------------------------------------------------------------
<         // Variable defintion: A
<         // Meaning: A[a][k] == 1 iff the 'a'-th HW-task is allocated to
<         //          the the 'k'-th partition
<         // ------------------------------------------------------------
< 
<         GRBVar2DArray A(t.maxHW_Tasks);
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<         {
<             GRBVarArray per_partition(t.maxPartitions);
<             A[a] = per_partition;
< 
<             for(uint k=0; k < t.maxPartitions; k++)
<                 A[a][k] = model.addVar(0.0, 1.0, 0.0, GRB_INTEGER);
<         }
< 
<         // ------------------------------------------------------------
<         // ------------------------------------------------------------
<         // Variable defintion: gamma
<         // Meaning: gamma[a]==1 iff the 'a'-th HW-task is subject to DPR
<         // ------------------------------------------------------------
< 
<         GRBVarArray gamma_part(t.maxHW_Tasks);
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<         {
<             gamma_part[a] = model.addVar(0.0, 1.0, 0.0, GRB_INTEGER);
<         }
< 
<         // ------------------------------------------------------------
<         // ------------------------------------------------------------
<         // Variable defintion: I_SLOT
<         // Meaning: I_SLOT[a][b] = interference caused by 'b'-th HW-Task
<         // to the 'a'-th HW-Task due to slot contention
<         // ------------------------------------------------------------
< 
<         GRBVar2DArray I_SLOT(t.maxHW_Tasks);
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<         {
<             GRBVarArray per_other_HWTask(t.maxHW_Tasks);
<             I_SLOT[a] = per_other_HWTask;
< 
<             for(uint b=0; b < t.maxHW_Tasks; b++)
<                 I_SLOT[a][b] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_CONTINUOUS);
<         }
< 
<         // ------------------------------------------------------------
<         // ------------------------------------------------------------
<         // Variable defintion: DELTA
<         // Meaning: DELTA[a][i] = interference caused by HW-Tasks used
<         // by the 'i'-th SW-Task to the 'a'-th HW-Task
<         // ------------------------------------------------------------
< 
<         GRBVar2DArray DELTA(t.maxHW_Tasks);
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<         {
<             GRBVarArray per_SWTask(t.maxSW_Tasks);
<             DELTA[a] = per_SWTask;
< 
<             for(uint i=0; i < t.maxSW_Tasks; i++)
<                 DELTA[a][i] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_CONTINUOUS);
<         }
< 
<         // ------------------------------------------------------------
<         // ------------------------------------------------------------
<         // Variable defintion: r
<         // Meaning: r[a] = reconfiguration time of 'a'-th HW-Task
<         // ------------------------------------------------------------
< 
<         GRBVarArray r(t.maxHW_Tasks);
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<         {
<             r[a] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_CONTINUOUS);
<         }
< 
< 
<         // ------------------------------------------------------------
<         // ------------------------------------------------------------
<         // Variable defintion: DELTA_NP
<         // Meaning: DELTA_NP[a][b] = interference due to non-preemptive
<         // reconfiguration *directly* incurred by the 'b'-th HW-Task
<         // during a request for the 'a'-th HW-Task
<         // ------------------------------------------------------------
< 
<         GRBVar2DArray DELTA_NP(t.maxHW_Tasks);
<         if(!preemptive_FRI)
<         {
<             for(uint a=0; a < t.maxHW_Tasks; a++)
<             {
<                 GRBVarArray per_other_HWTask(t.maxHW_Tasks);
<                 DELTA_NP[a] = per_other_HWTask;
< 
<                 for(uint b=0; b < t.maxHW_Tasks; b++)
<                     DELTA_NP[a][b] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_CONTINUOUS);
<             }
<         }
251c133
<                     GRBVarArray constrs(100);
---
>                     GRBVarArray constrs(200);
254c136
<                     for(l = 0; l < 100; l++)
---
>                     for(l = 0; l < 200; l++)
259a142,161
>         GRBVar4DArray seg(3);
>         for(i = 0; i < 3; i++) {
>             GRBVar3DArray each_slot(num_slots);
>             seg[i] = each_slot;
> 
>             for(k = 0; k < num_slots; k++)  {
>                 GRBVar2DArray x_coord(2);
>                 seg[i][k] = x_coord;
> 
>                 for(j = 0; j < 2; j++) {
>                     GRBVarArray constrs(8);
>                     seg[i][k][j] = constrs;
> 
>                     for(l = 0; l < 8; l++)
>                         seg[i][k][j][l] = model.addVar(0.0, 1.0, 0.0, GRB_BINARY);
>                 }
>             }
>         }
> 
> 
299c201
<                 bram[i][k] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_INTEGER);
---
>                 bram[i][k] = model.addVar(0.0, bram_max, 0.0, GRB_INTEGER);
301c203
< //#ifdef dspp
---
> 
320c222
<                 dsp[i][k] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_INTEGER);
---
>                 dsp[i][k] = model.addVar(0.0, dsp_max, 0.0, GRB_INTEGER);
335c237
<                      beta[i][j] = model.addVar(0.0, 1.0, 0.0, GRB_BINARY);
---
>                     beta[i][j] = model.addVar(0.0, 1.0, 0.0, GRB_BINARY);
357c259
<                       tau[i][l][k] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_INTEGER);
---
>                     tau[i][l][k] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_INTEGER);
432c334
<          func: Omega[i][k] = 1 iff y_i + h_i >= y_k
---
>          func: Omega[i][k] = 1 iff if y_i + h_i >= y_k
478d379
< //#ifdef fbdn
515c416
<         /**********************************************************************https://www.youtube.com/watch?v=os0D15JkfAk
---
>         /**********************************************************************
577,611d477
< //#endif
<         /**********************************************************************
<          name: kappa
<          type: binary
<          func: this variable is used to formulate the constraint on wasted resources
<                 kappa[i][k] is a variable to constrain wasted resource type i in slot k
<         ***********************************************************************/
<   /*      GRBVar2DArray kappa(2);
<         for(i = 0; i < 2; i++) {
<             GRBVarArray each_slot(num_slots);
< 
<             kappa[i] = each_slot;
< 
<             for(k = 0; k < num_slots; k++)
<                 kappa[i][k] = model.addVar(0.0, 1.0, 0.0, GRB_BINARY);
<         }
< */
<         /**********************************************************************
<          name: constr_res
<          type: binary
<          func: this variable is used to formulate the constraint on wasted resources
<                 constr_res[i][k] is a variable to constrain wasted resource type i in slot k
<         ***********************************************************************/
<   /*      GRBVar2DArray res_constr(2);
<         for(i = 0; i < 2; i++) {
<             GRBVarArray each_slot(num_slots);
< 
<             res_constr[i] = each_slot;
< 
<             for(k = 0; k < num_slots; k++)
<                 res_constr[i][k] = model.addVar(0.0, 1.0, 0.0, GRB_BINARY);
<         }
< 
<         cout<< "defining variables tau " <<endl;
< */
627c493
<                  centroid[i][k] = model.addVar(0.0,  GRB_INFINITY, 0.0, GRB_INTEGER);
---
>                  centroid[i][k] = model.addVar(0.0,  GRB_INFINITY, 0.0, GRB_CONTINUOUS);
648c514
<                      dist[j][i][k] = model.addVar(0.0, GRB_INFINITY, 0.0, GRB_INTEGER);
---
>                      dist[j][i][k] = model.addVar(0, GRB_INFINITY, 0.0, GRB_CONTINUOUS);
667c533
<                   wasted[i][k] = model.addVar(0.0,  GRB_INFINITY, 0.0, GRB_INTEGER);
---
>                   wasted[i][k] = model.addVar(0,  GRB_INFINITY, 0.0, GRB_INTEGER);
670,752c536,540
<         model.update();
< 
< 
<         /********************************************************************
<          Constraint 0.1: Every HW-Task must be allocated somewhere
<        ***********************************************************************/
< 
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<         {
<             GRBLinExpr exp;
< 
<             for(uint k=0; k < t.maxPartitions; k++)
<                 exp += A[a][k];
< 
<             model.addConstr(exp == 1, "con 1");
<         }
< 
<         /********************************************************************
<          Constraint 0.2: Decide wether a HW-task is subject to DPR
<         ***********************************************************************/
< 
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<             for(uint b=0; b < t.maxHW_Tasks; b++)
<             {
<                 if(a==b) continue;
< 
<                 for(uint k=0; k < t.maxPartitions; k++)
<                     model.addConstr(gamma_part[a] >= A[b][k] -(1-A[a][k]), "con 2");
<             }
< 
<         /********************************************************************
<          Constraint 0.3: Feasibility condition for the resources avaialable
<                          on the FPGA
<         ***********************************************************************/
< 
<         for(uint x=0; x < platform.N_FPGA_RESOURCES; x++)
<         {
<             GRBLinExpr exp;
< 
<             for(uint k=0; k < t.maxPartitions; k++)
<                     exp += b[x][k];
< 
<             model.addConstr(exp <= (double)platform.maxFPGAResources[x], "con 3");
<         }
< 
<         /********************************************************************
<          Constraint 0.4: Each slot must have enough resources to host all the
<                         HW-Tasks allocated to its corresponding partition
<         ***********************************************************************/
< 
<         for(uint x=0; x < platform.N_FPGA_RESOURCES; x++){
<             for(uint k=0; k < t.maxPartitions; k++) {
<                 GRBLinExpr exp;
<                 for(uint a=0; a < t.maxHW_Tasks; a++){
<                     model.addConstr(b[x][k] >= (double)t.HW_Tasks[a].resDemand[x]*A[a][k], "con 4");
<                     exp += A[a][k];
<                 }
<                 model.addConstr(b[x][k] <= (double)BIG_M * exp, "con 11");
<             }
<         }
< 
<         /********************************************************************
<         Constraint 0.5: Bound the FPGA reconfiguration time
<         ***********************************************************************/
< 
<         double BIG_M_con5 = 1;
<         for(uint x=0; x < platform.N_FPGA_RESOURCES; x++)
<             BIG_M_con5 += platform.recTimePerUnit[x]*platform.maxFPGAResources[x];
< 
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<             for(uint k=0; k < t.maxPartitions; k++)
<             {
<                     GRBLinExpr exp;
< 
<                     for(uint x=0; x < platform.N_FPGA_RESOURCES; x++)
<                         exp += (double)platform.recTimePerUnit[x]*b[x][k];
< 
< 
<                     model.addConstr(r[a] >= exp -(1.0 - A[a][k])*BIG_M_con5
<                                                 -(1.0 - gamma_part[a])*BIG_M_con5, "con 6");
<             }
<         /********************************************************************
<         Constraint 0.6: Interference among HW-tasks due to execution
---
>           /**********************************************************************
>            name: kappa
>            type: binary
>            func: this variable is used to formulate the constraint on wasted resources
>                   kappa[i][k] is a variable to constrain wasted resource type i in slot k
753a542,544
>           GRBVar2DArray kappa(num_slots);
>           for(i = 0; i < num_slots; i++) {
>               GRBVarArray each_slot(13);
755,816c546
<         for(uint k=0; k < t.maxPartitions; k++)
<             for(uint a=0; a < t.maxHW_Tasks; a++)
<                 for(uint b=0; b < t.maxHW_Tasks; b++)
<                 {
<                     // Self-interference is impossible
<                     if(a==b) continue;
< 
<                     const double WCET = (double)t.HW_Tasks[b].WCET;
< 
<                     model.addConstr(I_SLOT[a][b] >= WCET - WCET*(1-A[a][k])
<                                                          - WCET*(1-A[b][k]), "con 7");
<                 }
< 
<         /********************************************************************
<          Constraint 0.7: Bound on delay incurred when requesting a HW-Task
<         ***********************************************************************/
< 
<         double BIG_M_con7 = 1;
<         for(uint x=0; x < platform.N_FPGA_RESOURCES; x++)
<             BIG_M_con7 += platform.recTimePerUnit[x]*platform.maxFPGAResources[x];
<         for(uint b=0; b < t.maxHW_Tasks; b++)
<             BIG_M_con7 += t.HW_Tasks[b].WCET;
< 
<         for(uint a=0; a < t.maxHW_Tasks; a++)
<         {
<             for(uint i=0; i < t.maxSW_Tasks; i++)
<             {
<                 // Cannot receive interference from HW-tasks used by its SW-Task
<                 if(t.HW_Tasks[a].SW_Task_ID == i) continue;
< 
<                 // For each HW-task used by the 'i'-th SW-task...
<                 for(auto b : t.SW_Tasks[i].H)
<                     model.addConstr(DELTA[a][i] >= I_SLOT[a][b] + r[b] -(1-gamma_part[a])*BIG_M_con7, "con 8");
< 
<             }
<         }
<         /********************************************************************
<          Constraint 0.8: Enforce (delays <= given bound) to ensure schedulability
<         ***********************************************************************/
< 
<         for(uint i=0; i < t.maxSW_Tasks; i++)
<         {
<             GRBLinExpr exp;
< 
<             // For each HW-task used by the 'i'-th SW-task...
<             for(auto a : t.SW_Tasks[i].H)
<             {
<                 exp += r[a] + t.HW_Tasks[a].WCET;
< 
<                 for(uint j=0; j < t.maxSW_Tasks; j++)
<                 {
<                     if(i==j) continue;
< 
<                     exp += DELTA[a][j];
<                 }
< 
<                 if(!preemptive_FRI)
<                 {
<                     for(uint b=0; b < t.maxHW_Tasks; b++)
<                         exp += DELTA_NP[a][b];
<                 }
<             }
---
>               kappa[i] = each_slot;
818,835c548,550
<             model.addConstr(exp <= slacks[i], "con 9");
<         }
<         
<         /********************************************************************
<          Constraint 0.9: Bound delay due to non-preemptive reconfiguration
<         *********************************************************************/
< /*
<         if(!preemptive_FRI)
<         {
<             for(uint a=0; a < t.maxHW_Tasks; a++)
<                 for(uint b=0; b < t.maxHW_Tasks; b++)
<                     for(uint c=0; c < t.maxHW_Tasks; c++)
<                         for(uint k=0; k < t.maxPartitions; k++)
<                             model.addConstr(DELTA_NP[a][b] >= r[c]
<                                             -(2-A[a][k]-A[b][k])*BIG_M_con5
<                                             -A[c][k]*BIG_M_con5 -(1-gamma_part[a])*BIG_M_con5
<                                             -(1-gamma_part[c])*BIG_M_con5, "con 10");
<         }
---
>               for(k = 0; k < 13; k++)
>                   kappa[i][k] = model.addVar(0.0, 1.0, 0.0, GRB_BINARY);
>           }
837c552,553
< */
---
>         //add variables
>         model.update();
844,849c560,561
<             //for(k = 0; k< num_slots; k++) {
<                 model.addConstr(w[i] == x[i][1] - x[i][0], "1");
<                 //model.addConstr(x[i][0] <= W-1, "2");
<                 //model.addConstr(x[i][1] <= W, "3");
<                 model.addConstr(x[i][1] - x[i][0] >= 1, "4");
<             //}
---
>             model.addConstr(w[i] == x[i][1] - x[i][0], "1");
>             model.addConstr(x[i][1] - x[i][0] >= 1, "4");
857,874c569,572
<         for(i = 0; i < num_slots; i++) {
<              for(j = 0; j < num_clk_regs - 2; j++) {
<                  if(num_clk_regs > 2)
<                      model.addConstr(beta[i][j+1] >= beta[i][j] + beta[i][j+2] - 1, "5");
<              }
<          }
< /*
<         for(i = 0; i < num_slots; i++) {
<             GRBLinExpr exp = 0;
<             for(j = 0; j < num_clk_regs; j++) {
<                 //GRBLinExpr exp = 0;
< //                for(k = 0; k < num_rows; k++) {
<                     exp += beta[i][j];
<                 }
< 
<              for(l = 0; l < num_clk_regs; l++) {
<                     model.addConstr(beta[i][l] >= (h[i] - (exp - beta[i][l])), "500");
<                 }
---
>        for(i = 0; i < num_slots; i++) {
>             for(j = 0; j < num_clk_regs - 2; j++) {
>                 if(num_clk_regs > 2)
>                     model.addConstr(beta[i][j+1] >= beta[i][j] + beta[i][j+2] - 1, "5");
876c574
< */
---
>         }
896a595
> 
901,909c600,611
<                     x       0  <= x < 4
<                     x-1     4  <= x < 7
<                     x-2     7  <= x < 10
<                     x-3     10 <= x < 15
<                     x-4     15 <= x < 18
<                     x-5     18 <= x < 22
<                     x-6     22 <= x < 25
<                     x-7     25 <= x < W
< 
---
>                     x       0  <= x < 5
>                     x-1     4  <= x < 8
>                     x-2     7  <= x < 13
>                     x-3     10 <= x < 16
>                     x-4     15 <= x < 21
>                     x-5     18 <= x < 24
>                     x-6     22 <= x < 35
>                     x-7     10 <= x < 55
>                     x-8     15 <= x < 58
>                     x-9     18 <= x < 63
>                     x-10     22 <= x < 66
>                     x-11    25 <= x < W
917,930c619,640
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 4 - x[i][k], "1");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 3, "2");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 7 - x[i][k], "3");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 6, "4");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 10 - x[i][k], "5");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 9,  "6");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 15 - x[i][k], "7");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 14, "8");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 18 - x[i][k], "9");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 17, "10");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 22 - x[i][k], "11");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 21, "12");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 25 - x[i][k], "13");
<                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 24, "14");
---
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 5 - x[i][k], "1");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 4, "2");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 8 - x[i][k], "3");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 7, "4");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 13 - x[i][k], "5");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 12,  "6");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 16 - x[i][k], "7");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 15, "8");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 21 - x[i][k], "9");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 20, "10");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 24 - x[i][k], "11");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 23, "12");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 35 - x[i][k], "13");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 34, "14");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 55 - x[i][k], "7");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 54, "8");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 58 - x[i][k], "9");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 57, "10");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 63 - x[i][k], "11");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 62, "12");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= 66 - x[i][k], "13");
>                 model.addConstr(BIG_M * z[0][i][k][l++]  >= x[i][k] - 65, "14");
936c646
<                 model.addConstr(exp <= (l + 1) /2, "15_1");
---
>                 model.addConstr(exp <= (l + 1) /2);
965a676,688
> 
>                 model.addConstr(clb[i][k] >= (x[i][k] - 8)  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                            BIG_M * (1 - z[0][i][k][l++]), "12");
> 
>                 model.addConstr(clb[i][k] >= (x[i][k] - 9)  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                            BIG_M * (1 - z[0][i][k][l++]), "13");
> 
>                 model.addConstr(clb[i][k] >= (x[i][k] - 10)  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                            BIG_M * (1 - z[0][i][k][l++]), "14");
> 
>                 model.addConstr(clb[i][k] >= (x[i][k] - 11)  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                            BIG_M * (1 - z[0][i][k][l++]), "15");
> 
991a715,726
> 
>                 model.addConstr(x[i][k] - 8 >= (clb[i][k])  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                        BIG_M * (1 - z[0][i][k][l++]), "20");
> 
>                 model.addConstr(x[i][k] - 9 >= (clb[i][k])  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                        BIG_M * (1 - z[0][i][k][l++]), "21");
> 
>                 model.addConstr(x[i][k] - 10 >= (clb[i][k])  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                        BIG_M * (1 - z[0][i][k][l++]), "22");
> 
>                 model.addConstr(x[i][k] - 11 >= (clb[i][k])  - BIG_M * (1 - z[0][i][k][l++]) -
>                                                        BIG_M * (1 - z[0][i][k][l++]), "23");
999,1002c734,740
<                     0     0  <=  x  < 4
<                     1     4  <=  x  < 18
<                     2     18 <=  x  < 25
<                     3     25 <=  x  < W
---
>                     0     0  <=  x  < 5
>                     1     5  <=  x  < 16
>                     2     18 <=  x  < 21
>                     3     4  <=  x  < 35
>                     4     18 <=  x  < 55
>                     5     18 <=  x  < 66
>                     6     25 <=  x  < W
1008,1013c746,757
<                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 4 - x[i][k], "32");
<                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 3, "33");
<                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 18 - x[i][k], "34");
<                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 17, "35");
<                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 25 - x[i][k], "36");
<                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 24, "37");
---
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 5 - x[i][k], "32");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 4, "33");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 16 - x[i][k], "34");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 15, "35");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 21 - x[i][k], "36");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 20, "37");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 35 - x[i][k], "34");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 34, "35");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 55 - x[i][k], "36");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 54, "37");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= 66 - x[i][k], "34");
>                 model.addConstr(BIG_M * z[1][i][k][l++]  >= x[i][k] - 65, "35");
1023d766
< //#ifdef bram
1037a781,790
>                 model.addConstr(bram[i][k] >= 4  - BIG_M * (1 - z[1][i][k][l++]) -
>                                                            BIG_M * (1 - z[1][i][k][l++]), "41");
> 
>                 model.addConstr(bram[i][k] >= 5  - BIG_M * (1 - z[1][i][k][l++]) -
>                                                            BIG_M * (1 - z[1][i][k][l++]), "42");
> 
>                 model.addConstr(bram[i][k] >= 6  - BIG_M * (1 - z[1][i][k][l++]) -
>                                                            BIG_M * (1 - z[1][i][k][l++]), "42");
> 
> 
1052a806,813
>                 model.addConstr(4 >= (bram[i][k])  - BIG_M * (1 - z[1][i][k][l++]) -
>                                                        BIG_M * (1 - z[1][i][k][l++]), "44");
> 
>                 model.addConstr(5 >= (bram[i][k])  - BIG_M * (1 - z[1][i][k][l++]) -
>                                                        BIG_M * (1 - z[1][i][k][l++]), "45");
> 
>                 model.addConstr(6 >= (bram[i][k])  - BIG_M * (1 - z[1][i][k][l++]) -
>                                                        BIG_M * (1 - z[1][i][k][l++]), "46");
1056,1058d816
< //#endif
< 
< //#ifdef dspp
1061,1063c819,824
<                     0     0  <=  x  < 7
<                     1     7  <=  x  < 22
<                     2     22 <=  x  < W
---
>                     0     0  <=  x  < 8
>                     1     7  <=  x  < 13
>                     2     0  <=  x  < 24
>                     3     7  <=  x  < 58
>                     4     0  <=  x  < 63
>                     5     22 <=  x  < W
1069,1072c830,839
<                 model.addConstr(BIG_M * z[2][i][k][l++]  >= 7 - x[i][k], "47");
<                 model.addConstr(BIG_M * z[2][i][k][l++]  >= x[i][k] - 6, "48");
<                 model.addConstr(BIG_M * z[2][i][k][l++]  >= 22 - x[i][k], "49");
<                 model.addConstr(BIG_M * z[2][i][k][l++]  >= x[i][k] - 21, "50");
---
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= 8 - x[i][k], "47");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= x[i][k] - 7, "48");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= 13 - x[i][k], "49");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= x[i][k] - 12, "50");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= 23 - x[i][k], "49");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= x[i][k] - 22, "50");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= 58 - x[i][k], "49");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= x[i][k] - 57, "50");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= 63 - x[i][k], "49");
>                 model.addConstr(BIG_M * z[2][i][k][l++]  >= x[i][k] - 62, "50");
1079c846
<            }
---
>             }
1091a859,867
> 
>                 model.addConstr(dsp[i][k] >= (3  - BIG_M * (1 - z[2][i][k][l++]) -
>                                                   BIG_M * (1 - z[2][i][k][l++])), "53");
> 
>                 model.addConstr(dsp[i][k] >= (4  - BIG_M * (1 - z[2][i][k][l++]) -
>                                                   BIG_M * (1 - z[2][i][k][l++])), "54");
> 
>                 model.addConstr(dsp[i][k] >= (5  - BIG_M * (1 - z[2][i][k][l++]) -
>                                                   BIG_M * (1 - z[2][i][k][l++])), "53");
1102a879,885
>                 model.addConstr(3 >= (dsp[i][k])  - BIG_M * (1 - z[2][i][k][l++]) -
>                                                     BIG_M * (1 - z[2][i][k][l++]), "56");
> 
>                 model.addConstr(4 >= (dsp[i][k])  - BIG_M * (1 - z[2][i][k][l++]) -
>                                                     BIG_M * (1 - z[2][i][k][l++]), "57");
>                 model.addConstr(5 >= (dsp[i][k])  - BIG_M * (1 - z[2][i][k][l++]) -
>                                                     BIG_M * (1 - z[2][i][k][l++]), "56");
1105,1112d887
< //#endif
< /*
<         for(i = 0; i < num_slots; i++) {
<             model.addConstr(BIG_M * res_constr[0][i] >= (bram_req[i] - 9), "333");
<             model.addConstr(BIG_M * res_constr[1][i] >= (dsp_req[i]), "334");
<             model.addConstr(BIG_M * kappa[1][i] >= res_constr[0][i] + res_constr[1][i] - 1, "335");
<             model.addConstr(kappa[1][i] >= 0);
<         }*/
1119c894
<             GRBLinExpr exp_tau, exp_res, exp_bram, exp_dsp, exp_hw_task;
---
>             GRBLinExpr exp_tau, exp_res, exp_bram, exp_dsp;
1121c896,897
<                 model.addConstr(tau[0][i][j] <= 10000 * beta[i][j], "58");
---
>                 //CLB constraints
>                 model.addConstr(tau[0][i][j] <= 1000 * beta[i][j], "58");
1125,1126c901,903
< //#ifdef bram
<                 model.addConstr(tau[1][i][j] <= 10000 * beta[i][j], "61");
---
> 
>                 //BRAM constraints
>                 model.addConstr(tau[1][i][j] <= 1000 * beta[i][j], "61");
1130d906
< //#endif
1132,1133c908,909
< //#ifdef dspp
<                 model.addConstr(tau[2][i][j] <= 10000 * beta[i][j], "64");
---
>                 //DSP constraints
>                 model.addConstr(tau[2][i][j] <= 1000 * beta[i][j], "64");
1139d914
< //#endif
1142d916
< 
1143a918,919
>             model.addConstr(clb_per_tile * exp_res >= clb_req_pynq[i],"68");
>             model.addConstr(wasted[i][0] == (clb_per_tile * exp_res) - clb_req_pynq[i],"168"); //wasted clbs
1145,1165c921,922
<             //partitioning patch
<             for(int a = 0; a < task_set->maxHW_Tasks; a++)
<                 exp_hw_task += A[a][i];
< 
<             //model.addConstr(clb_per_tile * exp_res >= clb_req_zynq[i],"68");
<             //model.addConstr(wasted[i][0] == (clb_per_tile * exp_res) - clb_req_zynq[i],"168"); //wasted clbs
<             
<             //partitioning patch
<             model.addConstr(clb_per_tile * exp_res >= b[0][i],"68");
<             model.addConstr(clb_per_tile * exp_res <= BIG_M * exp_hw_task, "con hw1");
<             model.addConstr(wasted[i][0] == (clb_per_tile * exp_res) - b[0][i],"168"); //wasted clbs
< 
< //#ifdef bram
<             //model.addConstr(bram_per_tile * exp_bram >= bram_req_zynq[i],"69");
<             //model.addConstr(wasted[i][1] == bram_per_tile * exp_bram - bram_req_zynq[i] ,"169");
<             
<             //partitioning patch
<             model.addConstr(bram_per_tile * exp_bram >= b[1][i],"69");
<             model.addConstr(bram_per_tile * exp_bram <= BIG_M * exp_hw_task, "con hw1");
<             model.addConstr(wasted[i][1] == bram_per_tile * exp_bram - b[1][i] ,"169");
< //#endif
---
>             model.addConstr(bram_per_tile * exp_bram >= bram_req_pynq[i],"69");
>             model.addConstr(wasted[i][1] == (bram_per_tile * exp_res) - bram_req_pynq[i],"169"); //wasted brams
1167,1175c924,925
< //#ifdef dspp
<             //model.addConstr(dsp_per_tile * exp_dsp >= dsp_req_zynq[i],"70");
<             //model.addConstr(wasted[i][2] == (dsp_per_tile * exp_dsp) - dsp_req_zynq[i], "170");
<             
<             //partitioning patch
<             model.addConstr(dsp_per_tile * exp_dsp >= b[2][i],"70");
<             model.addConstr(dsp_per_tile * exp_dsp <= BIG_M * exp_hw_task, "con hw1");
<             model.addConstr(wasted[i][2] == (dsp_per_tile * exp_dsp) - b[2][i], "170");
< //#endif
---
>             model.addConstr(dsp_per_tile * exp_dsp >= dsp_req_pynq[i],"70");
>             model.addConstr(wasted[i][2] == (dsp_per_tile * exp_dsp) - dsp_req_pynq[i], "170");
1180c930,933
<         Constraint 3.0: The semantics of Gamma, Alpha, Omega & Psi must be fixed
---
>         Constraint 3.0: The semantics of Gamma, Alpha, Omega                 for(l = 0; l < 10; l++)
>                     exp += z[1][i][k][l];
> 
>                 model.addConstr(exp <= 6, "49000");& Psi must be fixed
1182a936
>             GRBLinExpr exp;
1186,1187c940,944
< /*              model.addConstr(BIG_M * gamma[i][k] >= x[k][0] - x[i][0], "63");
<                 model.addConstr(BIG_M * theta[i][k] >= (y[k] - y[i]) * num_rows, "64");
---
>  //               model.addConstr(BIG_M * gamma[i][k] >= x[k][0] - x[i][0], "63");
> //                model.addConstr(BIG_M * Gamma[i][k] >= x[i][0] - x[k][0], "65");
> 
> //                model.addConstr(gamma[i][k] + Gamma[i][k] == 1, "res");
> /*                model.addConstr(BIG_M * theta[i][k] >= (y[k] - y[i]), "64");
1190,1191c947,948
<                 model.addConstr(BIG_M * Omega[i][k] >= y[i] * num_rows + h[i] - y[k] * num_rows, "67");
<                 model.addConstr(BIG_M * Psi[i][k]   >= y[k] * num_rows + h[k] - y[i] * num_rows, "68");
---
>                 model.addConstr(BIG_M * Omega[i][k] >= y[i] + h[i] - y[k], "67");
>                 model.addConstr(BIG_M * Psi[i][k]   >= y[k] + h[k] - y[i], "68");
1207d963
<             GRBLinExpr exp_delta;
1210a967
> 
1219a977,982
> 
> 
> 
> //               for(j = 0; j < num_clk_regs; j++) {
>  //                   model.addConstr(x[k][0] >= x[i][1] - (3 - gamma[i][k] - beta[i][j] - beta[k][j]) * BIG_M, "777");
>  //               }
1223d985
< //#ifdef fbdn
1228c990,994
< /*
---
>         for(i = 0; i < num_forbidden_slots; i++) {
>             for(j = 0; j < num_slots; j++)
>                 model.addConstr(mu[i][j] >= 0);
>         }
> 
1231,1236c997,1011
<                 model.addConstr(BIG_M * mu[i][k]     >= x[k][0] - fs_zynq[i].x, "74");
<                 model.addConstr(BIG_M * nu[i][k]     >= y[k] * num_rows - fs_zynq[i].y, "75");
<                 model.addConstr(BIG_M * fbdn_1[i][k] >= fs_zynq[i].x + fs_zynq[i].w - x[k][0] + 1, "76");
<                 model.addConstr(BIG_M * fbdn_2[i][k] >= x[k][1]    - fs_zynq[i].x + 1, "77");
<                 model.addConstr(BIG_M * fbdn_3[i][k] >= fs_zynq[i].y + fs_zynq[i].h - y[k] * num_rows + 1, "78");
<                 model.addConstr(BIG_M * fbdn_4[i][k] >= y[k] * num_rows + h[k] - fs_zynq[i].y + 1, "79");
---
> //              model.addConstr(BIG_M * mu[i][k]  >= x[k][0] - fs_pynq[i].x, "74");
> 
>                 model.addConstr(BIG_M * mu[i][k]     >= x[k][0] - fs_pynq[i].x, "74");
>                 model.addConstr(BIG_M * nu[i][k]     >= y[k] * num_rows   - fs_pynq[i].y, "75");
>                 model.addConstr(BIG_M * fbdn_1[i][k] >= fs_pynq[i].x + fs_pynq[i].w - x[k][0] + 1, "76");
>                 model.addConstr(BIG_M * fbdn_2[i][k] >= x[k][1]    - fs_pynq[i].x + 1, "77");
>                 model.addConstr(BIG_M * fbdn_3[i][k] >= fs_pynq[i].y + fs_pynq[i].h - (y[k] * num_rows) + 1, "78");
>                 model.addConstr(BIG_M * fbdn_4[i][k] >= (y[k] + h[k]) * num_rows - fs_pynq[i].y + 1, "79");
> 
>                 //model.addConstr(BIG_M * mu[i][k]     >= x[k][0] - fs_pynq[i].x, "74");
>                 //model.addConstr(BIG_M * nu[i][k]     >= y[k] * num_rows   - fs_pynq[i].y, "75");
>                 //model.addConstr(BIG_M * fbdn_1[i][k] >= fs_pynq[i].x + fs_pynq[i].w - x[k][0] + 1, "76");
>                 //model.addConstr(BIG_M * fbdn_2[i][k] >= x[k][1] - fs_pynq[i].x + 1, "77");
>                 //model.addConstr(BIG_M * fbdn_3[i][k] >= fs_pynq[i].y + fs_pynq[i].h - (y[k] * num_rows) + 1, "78");
>                 //model.addConstr(BIG_M * fbdn_4[i][k] >= (y[k] + h[k]) * num_rows - fs_pynq[i].y + 1, "79");
1239c1014
< */
---
> 
1243,1244c1018
< /*
<         for(i = 0; i < num_forbidden_slots; i++) {
---
>        for(i = 0; i < num_forbidden_slots; i++) {
1247a1022
> 
1248a1024
> 
1249a1026
> 
1250a1028
> 
1253d1030
<                 //exp_delta += delta[1][i][k];
1255c1032,1037
<             }
---
> 
> //                for(j = 0; j < num_clk_regs; j++) {
> //                    model.addConstr(x[k][0] >= fs_pynq[i].x + fs_pynq[i].w - (3 - mu[i][k] - clk_reg_fbdn[i][j] - beta[k][j]) * BIG_M, "777");
>                     //model.addConstr(x[k][1] <= fs_pynq[i].x - (3 - fbdn_2[i][k] - clk_reg_fbdn[i][j] - beta[k][j]) * BIG_M, "787");
>   //              }
>           }
1257,1258d1038
< */
< //#endif
1260d1039
< //#ifdef objective
1304,1308c1083,1087
<         if(num_conn_slots_zynq > 0) {
<         for(i = 0; i < num_conn_slots_zynq; i++) {
<                 dist_0 = conn_matrix_zynq[i][0] - 1;
<                 dist_1 = conn_matrix_zynq[i][1] - 1;
<                 dist_2 = conn_matrix_zynq[i][2];
---
>         if(num_conn_slots_pynq > 0) {
>         for(i = 0; i < num_conn_slots_pynq; i++) {
>                 dist_0 = conn_matrix_pynq[i][0] - 1;
>                 dist_1 = conn_matrix_pynq[i][1] - 1;
>                 dist_2 = conn_matrix_pynq[i][2];
1315,1316c1094,1095
<         for(i = 0; i < num_conn_slots_zynq; i++) {
<             wl_max += conn_matrix_zynq[i][2] * (W + H * 20);
---
>         for(i = 0; i < num_conn_slots_pynq; i++) {
>             wl_max += conn_matrix_pynq[i][2] * (W + H * 20);
1320,1326c1099,1103
< }
< 
<         //model.setObjective((obj_x + obj_y), GRB_MINIMIZE);
<         //model.setObjective(1 * obj_wasted_clb,  GRB_MINIMIZE);
<         model.setObjective(obj_wasted_clb + obj_wasted_bram, GRB_MINIMIZE);
<        // model.setObjective(obj_wasted_dsp,  GRB_MINIMIZE);
< //#endif
---
>         }
>         // model.setObjective((obj_x + obj_y ) / wl_max, GRB_MINIMIZE);
>          //model.setObjective(obj_wasted_clb,  GRB_MINIMIZE);
>         //model.setObjective(obj_wasted_bram, GRB_MINIMIZE);
>          model.setObjective(obj_wasted_dsp,  GRB_MINIMIZE);
1333c1110
<         model.set(GRB_DoubleParam_TimeLimit, 120);
---
>         model.set(GRB_DoubleParam_TimeLimit, 1800);
1335,1337c1112,1114
<         wasted_clb_zynq = 0;
<         wasted_bram_zynq  = 0;
<         wasted_dsp_zynq  = 0;
---
>         wasted_clb_pynq = 0;
>         wasted_bram_pynq = 0;
>         wasted_dsp_pynq = 0;
1342,1408c1119
<         if(status == GRB_OPTIMAL) {
<             // ------------------------------------------------------------
<             // Partition OUTPUT
<             // ------------------------------------------------------------
<             cout << "--------------------------------------------------------------------" << endl;
<             cout << "-) HW-TASK ALLOCATION" << endl;
<             cout << "--------------------------------------------------------------------" << endl;
<             cout << endl;
<             cout << "Partition: \t\t";
<                 for(uint k=0; k < t.maxPartitions; k++)
<                     cout << k << "\t";
<                 cout << endl;
<             cout << "--------------------------------------------------------------------" << endl;
<             for(uint a=0; a < t.maxHW_Tasks; a++)
<             {
<                 cout << "HW-Task [" << a << "] : \t";
<                 for(uint k=0; k < t.maxPartitions; k++)
<                 {
<                     if((unsigned int)A[a][k].get(GRB_DoubleAttr_X))
<                         cout << "X" << "\t";
<                     else
<                         cout << " " << "\t";
<                     //cout << A[a][k].get(GRB_DoubleAttr_X) << "\t";
<                 }
< 
<                 cout << endl;
<             }
< //#ifdef dspppp
<             cout << endl;
<             cout << "--------------------------------------------------------------------" << endl;
<             cout << "-) RECONFIGURATION TIMES" << endl;
<             cout << "--------------------------------------------------------------------" << endl;
<             cout << endl;
< 
<             cout << endl;
< 
<             /*for(uint a=0; a < t.maxHW_Tasks; a++)
<                 for(uint b=0; b < t.maxHW_Tasks; b++)
<                     cout << "I_SLOT["<<a<<"]["<<b<<"] = " << I_SLOT[a][b].get(GRB_DoubleAttr_X)<<endl;*/
< 
<             for(uint a=0; a < t.maxHW_Tasks; a++)
<                 cout << "r["<<a<<"] = " << r[a].get(GRB_DoubleAttr_X)<<endl;
< 
<             for(uint a=0; a < t.maxHW_Tasks; a++){
<                 for(uint k=0; k < t.maxPartitions; k++)
<                     if((unsigned int)A[a][k].get(GRB_DoubleAttr_X))
<                         cout << "r["<<a<<"]["<<k<<"] = CLB " << b[0][a].get(GRB_DoubleAttr_X)<< " Bram " <<b[1][a].get(GRB_DoubleAttr_X)
<                              <<" DSP " <<b[2][a].get(GRB_DoubleAttr_X)<<endl;
<             }
< 
<             for(uint a=0; a < t.maxHW_Tasks; a++)
<                 cout << "gamma_part["<<a<<"] = " << gamma_part[a].get(GRB_DoubleAttr_X)<<endl;
< 
< //#endif
<             //stores the chosen partitions
<             vector <unsigned long> active_partitions (t.maxPartitions, 0);
< 
<             for(uint k=0; k < t.maxPartitions; k++)
<                 for(uint a=0; a < t.maxHW_Tasks; a++)
<                     if((unsigned int)A[a][k].get(GRB_DoubleAttr_X))
<                         active_partitions[k] = 1;
< 
<             for(uint k=0; k < t.maxPartitions; k++)
<                 num_active_partitions += active_partitions[k];
< 
<             cout<< "num partitions " <<num_active_partitions <<endl;
< 
---
>         if(status == GRB_OPTIMAL || status == GRB_TIME_LIMIT) {
1410,1411c1121
< ----------------------------------------------------------------------------------------------------\
< ------------------------  "<< endl;
---
> -------------------------------------------------------------------- "<< endl;
1416,1417c1126,1127
< --------------------------------------------------------------------------------------------\
< -------------------------------" << endl;
---
> ---------------------------------------------------------------------------------------------\
> -----------------------------------------------------------------" << endl;
1419c1129,1130
<             for(i = 0, m = 0; i < num_slots; i++) {
---
>                 for(i = 0; i < num_slots; i++) {
>                     cout <<endl;
1421,1431c1132,1167
<                 if(active_partitions[i]){
<                     (*to_sim->x)[m] = (int) x[i][0].get(GRB_DoubleAttr_X);
<                     (*to_sim->y)[m] = (int) y[i].get(GRB_DoubleAttr_X) * 10;
<                     (*to_sim->w)[m] = (int) w[i].get(GRB_DoubleAttr_X);
<                     (*to_sim->h)[m] = (int) h[i].get(GRB_DoubleAttr_X) * 10;
<                     (*to_sim->clb_from_solver)[m] = (int) ((clb[i][1].get(GRB_DoubleAttr_X) - clb[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * clb_per_tile);
<                     (*to_sim->bram_from_solver)[m] = (int) ((bram[i][1].get(GRB_DoubleAttr_X) - bram[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * bram_per_tile);
<                     (*to_sim->dsp_from_solver)[m] = (int) ((dsp[i][1].get(GRB_DoubleAttr_X) -    dsp[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * dsp_per_tile);
<                     
<                     m += 1;
<                 }
---
>                     cout << i << "\t" << x[i][0].get(GRB_DoubleAttr_X) <<"\t"
>                         << x[i][1].get(GRB_DoubleAttr_X) << "\t" << y[i].get(GRB_DoubleAttr_X)
>                         <<" \t" <<  w[i].get(GRB_DoubleAttr_X) << "\t" << h[i].get(GRB_DoubleAttr_X)
> 
>                         <<"\t" << clb[i][0].get(GRB_DoubleAttr_X) <<"\t" <<
>                         clb[i][1].get(GRB_DoubleAttr_X) << "\t" << (clb[i][1].get(GRB_DoubleAttr_X) -
>                          clb[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * clb_per_tile<< "\t" << clb_req_pynq[i]
> 
>                         <<"\t" << bram[i][0].get(GRB_DoubleAttr_X) <<"\t" <<
>                         bram[i][1].get(GRB_DoubleAttr_X) << "\t" << (bram[i][1].get(GRB_DoubleAttr_X) -
>                         bram[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * bram_per_tile<< "\t" << bram_req_pynq[i]
> 
>                         << "\t" << dsp[i][0].get(GRB_DoubleAttr_X) << "\t" <<
>                         dsp[i][1].get(GRB_DoubleAttr_X) << "\t" << (dsp[i][1].get(GRB_DoubleAttr_X) -
>                                 dsp[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * dsp_per_tile << "\t" << dsp_req_pynq[i] <<endl;
> 
>                         cout <<endl;
> 
>                         (*to_sim->x)[i] = (int) x[i][0].get(GRB_DoubleAttr_X);
>                         (*to_sim->y)[i] = (int) y[i].get(GRB_DoubleAttr_X) * 10;
>                         (*to_sim->w)[i] = (int) w[i].get(GRB_DoubleAttr_X);
>                         (*to_sim->h)[i] = (int) h[i].get(GRB_DoubleAttr_X) * 10;
>                         (*to_sim->clb_from_solver)[i] = (int) ((clb[i][1].get(GRB_DoubleAttr_X) - clb[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * clb_per_tile);
>                         (*to_sim->bram_from_solver)[i] = (int) ((bram[i][1].get(GRB_DoubleAttr_X) - bram[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * bram_per_tile);
>                         (*to_sim->dsp_from_solver)[i] = (int) ((dsp[i][1].get(GRB_DoubleAttr_X) - dsp[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * dsp_per_tile);
> 
>                         for(k=0; k < 2; k++) {
>                             for(l = 0; l < 16; l++)
>                              cout <<"z" << l << " " << z[0][i][k][l].get(GRB_DoubleAttr_X) << "\t";
>                              cout <<endl;
>                         }
> 
>                         for(k=0; k < num_clk_regs; k++) {
>                                 cout <<"b" << k << " " << beta[i][k].get(GRB_DoubleAttr_X) << "\t";
>                                 cout<<endl;
>                         }
1433c1169,1170
<                 cout <<endl;
---
>                         cout << endl;
>                         cout <<endl;
1435,1449c1172
<                 cout << i << "\t" << x[i][0].get(GRB_DoubleAttr_X) <<"\t"
<                     << x[i][1].get(GRB_DoubleAttr_X) << "\t" << y[i].get(GRB_DoubleAttr_X)
<                     <<" \t" <<  w[i].get(GRB_DoubleAttr_X) << "\t" << h[i].get(GRB_DoubleAttr_X)
< 
<                     <<"\t" << clb[i][0].get(GRB_DoubleAttr_X) <<"\t" <<
<                     clb[i][1].get(GRB_DoubleAttr_X) << "\t" << (clb[i][1].get(GRB_DoubleAttr_X) -
<                      clb[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * clb_per_tile << "\t" << task_set->HW_Tasks[i].resDemand[CLB]
< 
<                     <<"\t" << bram[i][0].get(GRB_DoubleAttr_X) <<"\t" <<
<                     bram[i][1].get(GRB_DoubleAttr_X) << "\t" << (bram[i][1].get(GRB_DoubleAttr_X) -
<                     bram[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * bram_per_tile << "\t" << task_set->HW_Tasks[i].resDemand[BRAM]
< 
<                     << "\t" << dsp[i][0].get(GRB_DoubleAttr_X) << "\t" <<
<                     dsp[i][1].get(GRB_DoubleAttr_X) << "\t" << (dsp[i][1].get(GRB_DoubleAttr_X) -
<                             dsp[i][0].get(GRB_DoubleAttr_X)) * h[i].get(GRB_DoubleAttr_X) * dsp_per_tile << "\t" << task_set->HW_Tasks[i].resDemand[DSP] <<endl;
---
>                 }
1450a1174,1178
>             for(k=0; k < num_forbidden_slots; k++) {
>                 for(j = 0; j < num_slots; j++)
>                     cout <<"mu" << k << j<< " " << mu[k][j].get(GRB_DoubleAttr_X) << "\t";
>                 cout<<endl;
>             }
1452c1180
<                     cout <<endl;
---
>             cout <<endl;
1454,1476d1181
<                     for(k=0; k < 2; k++) {
<                         for(l = 0; l < 5; l++)
<                          cout <<"z" << l << " " << z[0][i][k][l].get(GRB_DoubleAttr_X) << "\t";
<                          cout <<endl;
<                      }
< 
<                     for(k=0; k < 2; k++) {
<                         for(l = 0; l < 4; l++)
<                             cout <<"z" << l << " " << z[1][i][k][l].get(GRB_DoubleAttr_X) << "\t";
<                             cout<<endl;
<                     }
< 
<                     for(k=0; k < 2; k++) {
<                         for(l = 0; l < 4; l++)
<                             cout <<"z" << l << " " << z[2][i][k][l].get(GRB_DoubleAttr_X) << "\t";
<                             cout<<endl;
<                     }
< 
<                     cout <<  endl;
<             }
<             
<             to_sim->num_partition = num_active_partitions;
< /*
1478,1480c1183,1189
<                 wasted_clb_zynq  +=  wasted[i][0].get(GRB_DoubleAttr_X);
<                 wasted_bram_zynq +=  wasted[i][1].get(GRB_DoubleAttr_X);
<                 wasted_dsp_zynq  +=  wasted[i][2].get(GRB_DoubleAttr_X);
---
>                 wasted_clb_pynq  +=  wasted[i][0].get(GRB_DoubleAttr_X);
>                 wasted_bram_pynq +=  wasted[i][1].get(GRB_DoubleAttr_X);
>                 wasted_dsp_pynq  +=  wasted[i][2].get(GRB_DoubleAttr_X);
> 
>                 cout << "wasted clb " << wasted[i][0].get(GRB_DoubleAttr_X) <<
>                         " wasted bram " << wasted[i][1].get(GRB_DoubleAttr_X) <<
>                         " wasted dsp " << wasted[i][2].get(GRB_DoubleAttr_X) <<endl;
1482,1483c1191,1192
<                 cout << "wasted clb " << wasted[i][0].get(GRB_DoubleAttr_X) << " wasted bram " << wasted[i][1].get(GRB_DoubleAttr_X) <<
<                        " wasted dsp " << wasted[i][2].get(GRB_DoubleAttr_X) <<endl;
---
>                 cout<< "centroid " << i << " " << centroid[i][0].get(GRB_DoubleAttr_X) << " " <<
>                        centroid[i][1].get(GRB_DoubleAttr_X) <<endl;
1485d1193
<                 cout<< "centroid " << i << centroid[i][0].get(GRB_DoubleAttr_X) << " " <<centroid[i][1].get(GRB_DoubleAttr_X) <<endl;
1493d1200
< 
1496,1507c1203,1205
<                 cout << "total wasted clb " <<wasted_clb_zynq << " total wasted bram " <<
<                         wasted_bram_zynq << " total wastd dsp " << wasted_dsp_zynq <<endl;
<                 cout << " total wire length " << w_x << "  " << w_y << "  " <<  w_y + w_x << endl;
<          }
< */
<   
<   }
<   else {
< 
<                 model.set(GRB_IntParam_Threads, 8);
<                 model.set(GRB_DoubleParam_TimeLimit, 120);
<                 model.computeIIS();
---
>             cout << "total wasted clb " <<wasted_clb_pynq <<
>                     " total wasted bram " <<wasted_bram_pynq <<
>                     " total wastd dsp " << wasted_dsp_pynq <<endl;
1509,1514c1207
<             cout<< "the following constraints can not be satisfied" <<endl;
<             c = model.getConstrs();
< 
<             for(i = 0; i < model.get(GRB_IntAttr_NumConstrs); i++)
<                 if(c[i].get(GRB_IntAttr_IISConstr) == 1)
<                     cout << c[i].get(GRB_StringAttr_ConstrName) << endl;
---
>             cout << " total wire length " << w_x << "  " << w_y << "  " <<  w_y + w_x << endl;
1517,1518c1210,1214
<     /*else {
<        model.computeIIS();
---
>     else {
> 
>             model.set(GRB_IntParam_Threads, 8);
>             model.set(GRB_DoubleParam_TimeLimit, 120);
>             model.computeIIS();
1526,1527c1222
< 
<     } */
---
>     }
1541d1235
< 
1542a1237
> 
1545c1240
< int zynq_start_optimizer(param_to_solver *param, param_from_solver *to_sim)
---
> int pynq_start_optimizer(param_to_solver *param, param_from_solver *to_sim)
1547,1548d1241
<     
<     cout << "starting gurobi solver " <<endl;
1554,1555c1247,1248
<     num_slots = param->num_rm_modules;
<     num_forbidden_slots = param->num_forbidden_slots;
---
>     num_slots = param->num_slots;
>     num_forbidden_slots = param->forbidden_slots;
1557,1558c1250,1251
<     H = param->num_clk_regs;
<     W = param->width;
---
>     H =  param->num_clk_regs;
>     W =  param->width;
1561c1254
<     num_conn_slots_zynq = (param->num_connected_slots);
---
>     num_conn_slots_pynq = (param->num_connected_slots);
1566,1569d1258
<     task_set = param->task_set;
<     platform = param->platform;
<     slacks =   *param->slacks;
< 
1571,1575c1260,1264
<         clb_req_zynq[i]  = (*param->clb)[i];
<         bram_req_zynq[i] = (*param->bram)[i];
<         dsp_req_zynq[i]  = (*param->dsp)[i];
< 
<         //cout << "clb " << clb_req_zynq[i] << " bram " << bram_req_zynq[i] << "dsp " << dsp_req_zynq[i] << endl;
---
>         clb_req_pynq[i]  = (*param->clb)[i];
>         bram_req_pynq[i] = (*param->bram)[i];
>         dsp_req_pynq[i]  = (*param->dsp)[i];
>         //cout << "clb " << clb_req_pynq[i] << " bram " <<
>         //bram_req_pynq[i] << "dsp " << dsp_req_pynq[i] << endl;
1578c1267
<     for(i = 0; i < num_conn_slots_zynq; i++) {
---
>     for(i = 0; i < num_conn_slots_pynq; i++) {
1580c1269
<             conn_matrix_zynq[i][k] = (*(param->conn_vector)) [i][k];
---
>             conn_matrix_pynq[i][k] = (*(param->conn_vector)) [i][k];
1583,1584c1272,1273
<     m =0;
<     for(i = 0; i < num_conn_slots_zynq; i++) {
---
>         m =0;
>     for(i = 0; i < num_conn_slots_pynq; i++) {
1587,1588c1276,1281
<         temp = conn_matrix_zynq[i][m++] + conn_matrix_zynq[i][m++] + conn_matrix_zynq[i][m++];
<             cout << "inside solver " << temp << /*m << conn_matrix[i][m++] << " m " << m << conn_matrix[i][m++] << " m" << m << << conn_matrix[i][k] <<*/endl;
---
>         temp = conn_matrix_pynq[i][m++] + conn_matrix_pynq[i][m++] + conn_matrix_pynq[i][m++];
>             //cout << "inside solver " << temp << /*m <<
>             //conn_matrix_pynq[i][m++] << " m " << m <<
>             //conn_matrix_pynq[i][m++] << " m" << m << <<
>             //conn_matrix_pynq[i][k] <<*/endl;
> 
1590c1283
<             //cout << "k is " << k /*conn_matrix[i][k++] */<< endl;
---
>             //cout << "k is " << k /*conn_matrix_pynq[i][k++] */<< endl;
1592c1285
<            // cout << conn_matrix[i][k] << endl;
---
>            // cout << conn_matrix_pynq[i][k] << endl;
1593a1287
> 
1595,1596c1289,1292
<         fs_zynq[i] = (*param->fbdn_slot)[i];
<         //cout <<"forbidden " << num_forbidden_slots << " " << fs_zynq[i].x << " " << fs_zynq[i].y << " " << fs_zynq[i].h << " " << fs_zynq[i].w <<endl;
---
>         fs_pynq[i] = (*param->fbdn_slot)[i];
>         cout <<"forbidden " << num_forbidden_slots << " " <<
>                fs_pynq[i].x << " " << fs_pynq[i].y << " " <<
>                fs_pynq[i].h << " " << fs_pynq[i].w <<endl;
1598c1294
<         //cout << "finished copying" << endl;
---
>     //cout << "finished copying" << endl;
1600,1601c1296
<     //status = solve_milp(to_sim);
<     status = solve_milp(*task_set, *platform, slacks, false, to_sim); 
---
>     status = solve_milp_pynq(to_sim);
1603c1298
<     return 0;
---
> return 0;
